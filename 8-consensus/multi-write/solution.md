## `[multi-write]`

Для решения задачи консенсуса для $n$ потоков с помощью операции `multi-write` будем действовать следующим образом:

Для начала представим пустой граф. Добавляя вершину к графу, будем проводить направленные рёбра во все уже существующие вершины. После добавления любого количества вершин граф будет представлять из себя граф линейного порядка. То есть из любой вершины, идя по направленным рёбрам можно будет дойти до первой добавленной вершины.

Для реализации заведём $\frac{n(n-1)}{2}$ ячеек памяти, которые будут соответствовать рёбрам графа. Значение в ячейке будет соответствовать ориентации ребра.

Ещё заведём $n$ ячеек, отображающих, что вершина добавлена.

Также заведём $n$ ячеек, в которые будем записывать значения, предлагаемые потоками.

Операция `Decide(v)` будет выглядеть следующим образом:

1. `a[thread_index] = v`
2. При помощи `multi-write` в $n$ ячеек запишем в $n-1$ ячейку рёбер `thread_index`, а в ячейку состояния вершины `st[thread_index]` запишем `true`.
3. Теперь запустим обход в глубину, перебирая остальные вершины и ходя в те вершины, у которых стоит флаг `st` и в которые ведут рёбра из нашей. То есть
```python
dfs(x):
    for y = 0 to n - 1:
        if y == x:
            continue
        if st[y] and get_edge(x, y) == x:
            return dfs(y)
    return x
```
Эта операция найдёт первую добавленную вершину, так как на каждом шаге рекурсии переходит в вершину добавленную раньше (`multi-write` выполнился раньше), так как если вершина существует и ребро ведёт в неё, последнюю запись в ячейку ребра совершали мы, а значит, были добавлены позже.

4. `return a[dfs(thread_index)]`

