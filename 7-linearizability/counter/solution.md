### Счётчик с `Add(x)`

Рассмотрим следующее исполнение:
1. Поток T2 начал выполнять операцию `Get()`, выполнил `total += V[0]` (`total: 0`).
2. Поток T0 выполнил `Add(2)`
3. Поток T1 выполнил `Add(1)`
4. Поток T2 завершает выполнение с `total: 1`, с единицей прочитанной из `V[1]`.

При таком исполнении `Get()` вернул 1. Так как `Add(2)` завершился раньше, чем `Add(1)`, в любой линеаризации исполнения `Get()` должен возвращать 0, 2 или 3 (если вызов `Get()` находится до обоих `Add`, между ними, или после, соответственно), но вернул 1. Значит, эта реализация не являеся линеаризуемой.

### Счётчик с `Increment()`

Теперь рассмотрим случай с инкрементом. Покажем, что такая реализация как раз таки будет линеаризуемой. Для начала заметим следующий факт: 

    Вызов Get() всегда возвращает число не меньшее, чем сумма V[i] на момент начала вызова, и не большее, чем сумма на момент окончания. 

Теперь покажем, что для любого исполнения существует упорядочивание вызовом, удовлетворяющее последовательной спецификации:
1. Как-нибудь упорядочим вызовы `Increment()`.
2. Для каждого вызова `Get()` расположим его так, чтобы он находился после числа `Increment()`, равного возвращённому значению (это возможно благодаря факту, который был замечен выше и тому, что увеличение счётчика осуществляется лишь на 1, что даёт нам дискретную непрерывность).

Корректность порядка на вызовах `Increment()` тривиальна, между вызовами `Increment()` и `Get()` следует из второго пункта. Вызовы `Get()` будут упорядочены также корректно, так как если они не пересекаются, то поздний вернул не меньшее значение, чем ранний, что в случае неравенства автоматически приведёт к нужному порядку (их разделит один или несколько вызовов `Increment()`), а в случае с равенством можно будет упорядочить вызовы между собой ничего не сломав.
    
