Проблема `TicketLock`'а в том, что после освобождения лока, его нужно отдать
ожидающему потоку с наименьшим номером билета. Для реализации
этого функционала нужно в каком-то виде поддерживать очередь ожидающих
потоков, что и даёт overhead, обычно линейный по памяти (очередь).
Если же используется простой обход потоков для поиска минимального номера,
то при количестве потоков сильно больше, чем количество ядер, на поиск
нужного потока будет уходить много времени, что делает `TestAndSetLock`
быстрее `TicketLock`'а.