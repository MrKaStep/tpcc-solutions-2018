    unsigned int GetSize(x) {
        size = 0
        curr = head->next // skip left sentinel
        while (curr->next) { // curr != right sentinel
            if (!curr->marked) {
                ++size
            }
            curr = curr->next
        }
        return size
    }

Эта реализация не будет линеаризуема, так как может случиться следующее исполнение:
1. Поток T0 добавил два элемента: 1 и 2, в лист.
2. Поток T1 прошел одну итерацию цикла, `curr` указывает на элемент 2.
3. Поток T0 удалил 1 и добавил 3
4. Поток T1 прошел одну итерацию цикла, `curr` указывает на элемент 3.
5. Поток T0 удалил 2 и добавил 4
6. ...

Таким образом, процесс может продолжаться сколь угодно долго, при этом `size` будет увеличиваться, но размер очереди никогда не будет превосходить 2. Поэтому если завершить процесс так, чтобы было возвращено 3, вставить вызов `GetSize` в уже упорядоченную историю вызовов потока T0 будет невозможно.